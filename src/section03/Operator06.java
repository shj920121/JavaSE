package section03;
/*
 * 6. 비트 연산자
 * 	2진수로 표현된 두 비트 연산자
 * 	
 * 	& : 대응되는 비트가 모두 1이면 1을 반환 (비트 And 연산자)
 *  | : 대응되는 비트중 하나라도 1이면 1을 반환 (비트 Or 연산자)
 *  ^ : 대응되는 비트가 서로 다르면 1을 반환 (비트 XOR(Exclusive) 연산자)
 *  ~ : 대응되는 비트가 1이면 0으로, 0이면 1로 반전 (비트 Not 연산자)
 * 
 * 
 */
public class Operator06 {
	public static void main(String[] args) {
		int num1 = 3;	// 3 = 0011
		int num2 = 5;	// 5 = 0101
		
		System.out.println("num1 & num2: " + (num1 & num2));
		/*
		 * 	3 : 0011
		 * 	5 : 0101
		 *      ||||
		 *  &   0001
		 */		
		System.out.println("num1 | num2: " + (num1 | num2));
		/*
		 * 	3 : 0011
		 * 	5 : 0101
		 *      ||||
		 *  |   0111 -> 7
		 */			
		System.out.println("num1 ^ num2: " + (num1 ^ num2));
		/*
		 * 	3 : 0011
		 * 	5 : 0101
		 *      ||||
		 *  ^   0110 -> 6
		 */				
		System.out.println("~num1: " + ~num1);
		/*
		 * CPU는 1의 보수를 이용하여 뺄셈을 한다.  -> 2의보수 (1의보수 + 1)
		 * 0인 0000의 1의보수는 1 1111이다 -0		0 0000              // 0을 표현하는 숫자가 둘이 되어서 2의보수를 쓰게된다
		 * 1인 0001의 1의보수는 1 1110이다.-1		
		 * 2인 0010의 1의보수는 1 1101이다.-2
		 * 
		 * 5 - 3 = 2
		 * 
		 * 
		 * 5 : 0101										0101
		 * -3 : 0011 -> 1100(1의보수) -> 1101 (2의보수)     1101
		 * 											   10010 -> 1을 버려서 0010이 된다. -> 2
		 * 
		 * 
		 * ~3 : 1 1100
		 * 4 : 0 0100 -> 1 1011 -> 1 1100
		 * 
		 * 
		 *  (부호비트도 반전을 시킨다.)
		 */
		
		
		
		
		
	}
}
